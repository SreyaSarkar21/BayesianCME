# print(any(rowSums(abs(xmat))==0))
# cat("Range of xmat entries:\n")
# print(range(xmat))
#
# cat("Checking crossprod(xmat)...\n")
# cp_xmat <- crossprod(xmat)
# print(any(!is.finite(cp_xmat)))
# print(range(cp_xmat))
#
# cat("Checking priorvar_beta...\n")
# print(any(!is.finite(priorvar_beta)))
# print(range(priorvar_beta))
#
# cat("Checking vinv_beta_post before jitter...\n")
# vinv_beta_post <- cp_xmat + priorvar_beta
# print(any(!is.finite(vinv_beta_post)))
# print(range(vinv_beta_post))
vinv_beta_post <- crossprod(xmat) + priorvar_beta + diag(1e-6, nrow(priorvar_beta))
# if (any(!is.finite(vinv_beta_post))) stop("vinv_beta_post contains NA/Inf!")
# eig_vals <- eigen(vinv_beta_post, symmetric=TRUE, only.values=TRUE)$values
# print(range(eig_vals))
covBeta <- errVar * chol2inv(chol(vinv_beta_post))
xty <- crossprod(xmat, yvec)
muBeta <- drop(covBeta %*% xty) / errVar
betatilde <- muBeta + drop(crossprod(chol(covBeta), rnorm(pdims[d] * K)))
B_list[[d]] <- matrix(betatilde, pdims[d], K)
# message("Done B", d)
for(g in 1:K) {
lambda2_list[[d]][, g] <- 1 / rgamma(pdims[d], shape = 1,
rate = 1 / nu_list[[d]][, g] + (betatilde[((g-1)*pdims[d] + 1):(g*pdims[d])] ^ 2) / (2 * delta2_list[g] * errVar))
nu_list[[d]][, g] <- 1 / rgamma(pdims[d], shape = 1, rate = 1 + 1 / (lambda2_list[[d]][, g]))
# delta2_list[g] <- 1 / rgamma(1, shape = 0.5 * (pdims[d] + 1),
#                                   rate = 1 / xi_list[[d]][g] + sum((betatilde[((g-1)*pdims[d] + 1):(g*pdims[d])] * betatilde[((g-1)*pdims[d] + 1):(g*pdims[d])]) / (lambda2_list[[d]][, g])) / (2 * errVar))
# xi_list[g] <- 1 / rgamma(1, shape = 1, rate = 1 + 1 / delta2_list[g])
}
}
B <- B_cp(B_list)
### Given updated B, \lambda's, sample \delta^2_g and \xi_g ###
g_sums <- sapply(1:K, function(g) {
sum(sapply(1:nmodes, function(d) {
sum(B_list[[d]][, g]^2 / lambda2_list[[d]][, g])
}))
})
delta2_list <- 1 / rgamma(K, shape = 0.5 * (1 + sum(pdims)),
rate = 1 / xi_list + g_sums / (2 * errVar))
xi_list <- 1 / rgamma(K, shape = 1, rate = 1 + 1 / delta2_list)
################# Given updated B, sample \tau^2 #################
XijB_list <- lapply(Xijlist,
function(foo) {sum(as.vector(foo) * as.vector(B))})
mu_list <- lapply(1:n,
function(i) {
rows_i <- mis_starts[i]:mis_cumsum[i]
temp2 <- do.call("rbind", XijB_list[rows_i])
margVari_inv_half[[i]] %*% temp2
})
# mu_list <- vector("list", n)
# for(i in 1:n) {
#     temp2 <- do.call("rbind", XijB_list[((i-1)*m+1):(i*m)])
#     mu_list[[i]] <- margVari_inv_half[[i]] %*% temp2
# }
resids <- yvec - drop(do.call(rbind, mu_list))
shp_err <- a0 + 0.5 * (N + K * sum(pdims)) ## a0 = prior shape of errVar
scl_err <- b0 + 0.5 * (sum(resids^2)) ## b0 = prior scale of errVar
errVar <- 1 / rgamma(1, shape = shp_err, rate = scl_err)
#print("errVar Done")
####################################################################
##################### return samples #####################
list(BfactorsSamp = B_list,
BSamp = B, errVarSamp = errVar,
delta2Samplist = delta2_list, lambda2Samplist = lambda2_list,
nuSamplist = nu_list, xiSamplist = xi_list)
}
cmeSampler_SG <- function(yijs, Xijlist, Zijlist, mis, K,
a0, b0, gammaVar0, R_list, S_list,
niter, nburn, nthin) {
library(Matrix)
library(rTensor)
n <- length(mis); N <- sum(mis)
pdims <- dim(Xijlist[[1]]); qdims <- dim(Zijlist[[1]])
nmodes <- length(pdims)
kdims <- unlist(lapply(R_list, nrow))
mis_cumsum <- cumsum(mis)
mis_starts <- c(1, mis_cumsum[-length(mis)] + 1)
Sigma_gamma_list <- lapply(1:nmodes, function(d) {gammaVar0[d] * diag(kdims[d] * kdims[d])})
################## Storing final samples #####################
gammaSamplist <- lapply(1:nmodes, function(d) {matrix(NA, (niter - nburn) / nthin, kdims[d] * kdims[d])})
# betatildeSamplist <- lapply(1:nmodes, function(d) {matrix(NA, (niter - nburn) / nthin, pdims[d] * K)})
# GkronSamp <- matrix(NA, (niter - nburn) / nthin, prod(kdims) ^ 2)
betaSamp <- matrix(NA, (niter - nburn) / nthin, prod(pdims))
errVarSamp <- rep(NA, (niter - nburn) / nthin)
lambda2Samplist <- lapply(1:nmodes, function(d) {matrix(NA, (niter - nburn) / nthin, pdims[d] * K)})
nuSamplist <- lapply(1:nmodes, function(d) {matrix(NA, (niter - nburn) / nthin, pdims[d] * K)})
delta2Samp <- matrix(NA, (niter - nburn) / nthin, K) ## global shrinkage
xiSamp <- matrix(NA, (niter - nburn) / nthin, K)
#############################################################
####################### Initialization ######################
Gamma_list <- lapply(1:nmodes, function(d) {matrix(rnorm(kdims[d] * kdims[d], 0, sd = sqrt(gammaVar0[d])), kdims[d], kdims[d])})
#Bfactors <- lapply(1:nmodes, function(d) {matrix(0, pdims[d], K)})
#B <- B_cp(Bfactors) + array(rep(1e-4, prod(pdims)), dim = pdims)
#Bfactors <- lapply(1:nmodes, function(d) {matrix(runif(pdims[d] * K, -5, 5), pdims[d], K)})
#B <- B_cp(Bfactors)
errVar <- 1 / rgamma(1, shape = a0, rate = b0)
nu_list <- lapply(1:nmodes, function(d) {matrix(1/rgamma(pdims[d] * K, shape = 0.5, rate = 1), pdims[d], K)})
lambda2_list <- lapply(1:nmodes, function(d) {matrix(1/rgamma(pdims[d] * K, shape = 0.5, rate = 1/as.vector(nu_list[[d]])), pdims[d], K)})
xi_list <- 1 / rgamma(K, shape = 0.5, rate = 1)
delta2_list <- 1 / rgamma(K, shape = 0.5, rate = 1/xi_list)
######### ols initialization ##########
x_rows <- lapply(Xijlist, as.vector) ## Vectorize tensors X_ij's
X_mat <- do.call(rbind, x_rows)
gram_mat <- crossprod(X_mat)
# OLS estimate
beta_ols <- chol2inv(chol(gram_mat + diag(1e-6, nrow(gram_mat)), crossprod(X_mat, yijs)))
message("Done beta_ols")
B <- array(beta_ols, dim = pdims)
cp_B <- rTensor::cp(rTensor::as.tensor(B), num_components = K)
Bfactors <- cp_B$U
# # HOSVD initialization
# Bfactors <- list()
# for (d in 1:length(pdims)) {
#     unfold <- mode_matrix(B, d)
#     svd_res <- svd(unfold)
#     Bfactors[[d]] <- svd_res$u[,1:K] %*% diag(svd_res$d[1:K] ^(1/length(pdims)))
# }
###########################################################
#### compress Zij arrays ####
comp_Zijlist <- vector("list", N)
Skron_not1 <- LOORevKron(S_list, d = 1)
for(ij in 1:N) {
Zij_tilde_mode1 <- S_list[[1]] %*% tcrossprod(mode_matrix(Zijlist[[ij]], n = 1), Skron_not1)
comp_Zijlist[[ij]] <- array(Zij_tilde_mode1, dim = kdims)
}
#### vectorize the compressed Zij arrays ####
vec_comp_Zijlist <- lapply(comp_Zijlist,
function(foo) {as.vector(foo)})
###############################
Zi_tilde_list <- lapply(1:n,
function(i) {
rows_i <- mis_starts[i]:mis_cumsum[i]
do.call("rbind", vec_comp_Zijlist[rows_i])
})
# #### vectorize the original Zij arrays ####
# vec_Zijlist <- lapply(Zijlist,
#                       function(foo) {as.vector(foo)})
# Stkron <- t(kronAll(S_list))
# ###############################
# Zi_tilde_list <- vector("list", n)
# for(i in 1:n) {
#     rows_i <- mis_starts[i]:mis_cumsum[i]
#     Zi_tilde_list[[i]] <- do.call("rbind", vec_Zijlist[rows_i]) %*% Stkron
# }
cts <- 0
startTime <- proc.time()
for(its in 1:niter) {
if(its %% 1000 == 0) cat("iteration: ", its, "\n")
cycle1Samp <- cmeCycle1_SG(yijs = yijs, Xijlist = Xijlist, comp_Zijlist = comp_Zijlist,
Zi_tilde_list = Zi_tilde_list, mis = mis,
B = B, errVar = errVar,
Gamma_list = Gamma_list, Sigma_gamma_list = Sigma_gamma_list,
R_list = R_list)
###### Update Gamma's ######
Gamma_list <- cycle1Samp$GammaSamplist
#print("Cycle1 Done")
cycle2Samp <- cmeCycle2_SG(yijs = yijs, Xijlist = Xijlist,
Zi_tilde_list = Zi_tilde_list,
mis = mis,
B_list = Bfactors, K = K,
a0 = a0, b0 = b0, errVar = errVar,
lambda2_list = lambda2_list, delta2_list = delta2_list,
nu_list = nu_list, xi_list = xi_list,
Gamma_list = Gamma_list, R_list = R_list)
###### Update all other parameters ######
for(d in 1:nmodes) {
Bfactors[[d]] <- cycle2Samp$BfactorsSamp[[d]]
lambda2_list[[d]] <- cycle2Samp$lambda2Samplist[[d]]
nu_list[[d]] <- cycle2Samp$nuSamplist[[d]]
}
B <- cycle2Samp$BSamp
xi_list <- cycle2Samp$xiSamplist
delta2_list <- cycle2Samp$delta2Samplist
errVar <- cycle2Samp$errVarSamp
#print("Cycle2 Done")
### Store samples ###
if (its > nburn & its %% nthin == 0) {
cts <- cts + 1
for(d in 1:nmodes) {
gammaSamplist[[d]][cts, ] <- as.vector(cycle1Samp$GammaSamplist[[d]])
# betatildeSamplist[[d]][cts, ] <- as.vector(cycle2Samp$BfactorsSamp[[d]])
lambda2Samplist[[d]][cts, ] <- as.vector(cycle2Samp$lambda2Samplist[[d]])
nuSamplist[[d]][cts, ] <- as.vector(cycle2Samp$nuSamplist[[d]])
}
#GkronSamp[cts, ] <- as.vector(kronAll(cycle1Samp$GammaSamplist))
betaSamp[cts, ] <- as.vector(cycle2Samp$BSamp)
errVarSamp[cts] <- cycle2Samp$errVarSamp
delta2Samp[cts, ] <- cycle2Samp$delta2Samplist
xiSamp[cts, ] <- cycle2Samp$xiSamp
}
}
endTime <- proc.time()
list(gammaSamplist = gammaSamplist,
betaSamp = betaSamp, errVarSamp = errVarSamp,
lambda2Samplist = lambda2Samplist, nuSamplist = nuSamplist,
delta2Samp = delta2Samp, xiSamp = xiSamp,
sampler_time = endTime - startTime)
#GkronSamp = GkronSamp, betaFactorsSamp = betatildeSamplist,
}
a0 <- 0.01; b0 <- 0.01
niters <- 2100; nburns <- 100; nthins <- 1
nmodes <- length(pdims)
kdims <- rep(A[id, 4], nmodes)
R_list <- lapply(1:nmodes, function(d) {matrix(rnorm(kdims[d] * qdims[d], 0, sd = sqrt(1/kdims[d])), kdims[d], qdims[d])})
S_list <- lapply(1:nmodes, function(d) {matrix(rnorm(kdims[d] * qdims[d], 0, sd = sqrt(1/kdims[d])), kdims[d], qdims[d])})
res <- cmeSampler_SG(yijs = yijs, Xijlist = Xijlist, Zijlist = Zijlist,
mis = rep(A[id, 2], n_train), K = A[id, 3],
a0 = a0, b0 = b0, gammaVar0 = rep(1, nmodes),
R_list = R_list, S_list = S_list,
niter = niters, nburn = nburns, nthin = nthins)
id <- 2
A[id, ]
dat <- readRDS(paste0("/Volumes/argon_home/ArrayCME_Expts/arraydata/newdata/dataTrain_n_", n_train, "_m_", A[id, 2], "_Rep_", A[id, 1], "_lowrankL_cpB_trueRank2_sparse0.07_p1_", pdims[1], "_p2_", pdims[2], "_p3_", pdims[3], "_q1_", qdims[1], "_q2_", qdims[2], "_q3_", qdims[3], ".rds"))
yijs <- dat$yijs; Xijlist <- dat$Xijlist; Zijlist <- dat$Zijlist
res <- cmeSampler_SG(yijs = yijs, Xijlist = Xijlist, Zijlist = Zijlist,
mis = rep(A[id, 2], n_train), K = A[id, 3],
a0 = a0, b0 = b0, gammaVar0 = rep(1, nmodes),
R_list = R_list, S_list = S_list,
niter = niters, nburn = nburns, nthin = nthins)
A
rm(list=ls())
id <- 2
set.seed(12345)
pdims <- c(8, 8, 8) #c(5, 5, 2) #c(20, 10, 5)
qdims <- c(8, 8, 8) #c(2, 3, 4) #c(5, 2, 5)
#A <- matrix(c(25, 75, 125, 75, 75, 32, 64, 128, 4, 4, 4, 8, 12, 8, 4, 2), ncol = 2)
n_train <- 100; n_test <- 50
A <- as.matrix(expand.grid(Rep = c(1:9), m = c(3, 6, 9, 12), Kval = c(2, 5, 10), k = c(2, 4, 6)))
colnames(A) <- c("Rep", "m", "rankB", "k")
errVar <- 0.1
dat <- readRDS(paste0("/Volumes/argon_home/ArrayCME_Expts/arraydata/newdata/dataTrain_n_", n_train, "_m_", A[id, 2], "_Rep_", A[id, 1], "_lowrankL_cpB_trueRank2_sparse0.07_p1_", pdims[1], "_p2_", pdims[2], "_p3_", pdims[3], "_q1_", qdims[1], "_q2_", qdims[2], "_q3_", qdims[3], ".rds"))
yijs <- dat$yijs; Xijlist <- dat$Xijlist; Zijlist <- dat$Zijlist
A[id, ]
source("/Volumes/argon_home/helpersArray.R", echo = TRUE)
cmeCycle1_SG <- function(yijs, Xijlist, comp_Zijlist, Zi_tilde_list, mis,
B, errVar,
Gamma_list, Sigma_gamma_list, R_list) {
n <- length(mis); N <- sum(mis)
kdims <- unlist(lapply(R_list, nrow))
mis_cumsum <- cumsum(mis)
mis_starts <- c(1, mis_cumsum[-length(mis)] + 1)
nmodes <- length(kdims)
#### calculate residuals given B
check_y <- sapply(1:N, function(ij) {yijs[ij] - sum(as.vector(Xijlist[[ij]]) * as.vector(B))})
check_ylist <- lapply(1:n, function(i) {rows_i <- mis_starts[i]:mis_cumsum[i]; check_y[rows_i]})
#### Impute missing data \tilde D_i's ####
di <- vector("list", n)
Di_tilde <- vector("list", n)
Gkron <- kronAll(Gamma_list)
Rkron <- kronAll(lapply(R_list, tcrossprod))
for (i in 1:n) {
Vyd <- errVar * Zi_tilde_list[[i]] %*% Gkron %*% Rkron
VyyInv <- chol2inv(chol(Vyd %*% crossprod(Gkron, t(Zi_tilde_list[[i]])) + errVar * diag(1, nrow(Zi_tilde_list[[i]]))))
VydTvyyInv <- crossprod(Vyd, VyyInv)
postRanVar <- errVar * Rkron - drop(VydTvyyInv %*% Vyd)
postRanMean <- drop(VydTvyyInv %*% check_ylist[[i]])
di[[i]] <- postRanMean + drop(crossprod(chol(postRanVar), rnorm(length(postRanMean))))
Di_tilde[[i]] <- array(di[[i]], dim = kdims)
}
for(d in 1:nmodes) {
check_Z_gamma_groups <- vector("list", n)
for(i in 1:n) {
rows_i <- mis_starts[i]:mis_cumsum[i]
check_Z_gamma_groups[[i]]  <- do.call("rbind", lapply(comp_Zijlist[rows_i],
function(foo) {as.vector(mode_matrix(foo, d) %*% tcrossprod(LOORevKron(Gamma_list, d), mode_matrix(Di_tilde[[i]], d)))}))
}
check_Z_gamma <- do.call("rbind", check_Z_gamma_groups)
postVar_gamma <- chol2inv(chol(crossprod(check_Z_gamma) / errVar +
chol2inv(chol(Sigma_gamma_list[[d]]))))
postMean_gamma <- drop(postVar_gamma %*% crossprod(check_Z_gamma, check_y) / errVar)
gammaSamp <- postMean_gamma + drop(crossprod(chol(postVar_gamma), rnorm(length(postMean_gamma))))
Gamma_list[[d]] <- matrix(gammaSamp, kdims[d], kdims[d])
}
list(GammaSamplist = Gamma_list, Di_tilde = Di_tilde)
}
cmeCycle2_SG <- function(yijs, Xijlist, Zi_tilde_list, mis,
B_list, K, a0, b0,
errVar, lambda2_list, delta2_list, nu_list, xi_list,
Gamma_list, R_list) {
n <- length(mis); N <- sum(mis)
pdims <- dim(Xijlist[[1]])
nmodes <- length(pdims)
mis_cumsum <- cumsum(mis)
mis_starts <- c(1, mis_cumsum[-length(mis)] + 1)
######################## Marginalization ########################
Gkron <- kronAll(Gamma_list)
Rkron <- kronAll(lapply(R_list, tcrossprod))
margVari <- vector("list", n)
for(i in 1:n) {
margVari[[i]] <- Zi_tilde_list[[i]] %*% Gkron %*% Rkron %*% crossprod(Gkron, t(Zi_tilde_list[[i]])) + diag(1, nrow(Zi_tilde_list[[i]]))
}
margVari_svd <- lapply(margVari, svd)
margVari_inv_half <- vector("list", n)
for(i in 1:n) {
if(nrow(Zi_tilde_list[[i]]) == 1) {
margVari_inv_half[[i]] <- (margVari_svd[[i]]$u)*(margVari_svd[[i]]$u)/sqrt(margVari_svd[[i]]$d)
} else {
margVari_inv_half[[i]] <- margVari_svd[[i]]$u %*% tcrossprod(diag(1 / sqrt(margVari_svd[[i]]$d)), margVari_svd[[i]]$u)
}
}
ylist <- lapply(1:n,
function(i) {
rows_i <- mis_starts[i]:mis_cumsum[i]
margVari_inv_half[[i]] %*% yijs[rows_i]
})
# yvec <- as.matrix(unlist(ylist))
yvec <- as.matrix(unlist(ylist))
########################################################################
################# Given \tau^2, sample B in 3 steps #################
for(d in 1:nmodes) {
xmat_rowlist <- lapply(Xijlist,
function(foo) {as.vector(mode_matrix(foo, d) %*% B_lookr(B_list, d))})
xmat_list <- lapply(1:n,
function(i) {
rows_i <- mis_starts[i]:mis_cumsum[i]
temp <- do.call("rbind", xmat_rowlist[rows_i])
margVari_inv_half[[i]] %*% temp
})
# xmat_list <- vector("list", n)
# for(i in 1:n) {
#     temp <- do.call("rbind", xmat_rowlist[((i-1)*m+1):(i*m)])
#     xmat_list[[i]] <- margVari_inv_half[[i]] %*% temp
# }
xmat <- do.call(rbind, xmat_list) ## design matrix for sampling betatilde_d; d = 1, 2, 3
# cat("xmat rank:", qr(xmat)$rank, "/", ncol(xmat), "\n")
# cat("xmat mean abs:", mean(abs(xmat)), "\n")
# cat("delta2_list[[d]]:\n")
# print(delta2_list)
#
# cat("lambda2_list[[d]]:\n")
# print(lambda2_list[[d]])
# # Cap minimums
# delta2_list <- pmax(delta2_list, 1e-3)
# for (d in 1:nmodes) {
#     lambda2_list[[d]] <- pmax(lambda2_list[[d]], 1e-3)
# }
#
# # Confirm again
# for (d in 1:nmodes) {
#     if (any(lambda2_list[[d]] <= 0 | !is.finite(lambda2_list[[d]]))) {
#         stop("lambda2 contains nonpositive or nonfinite entries!")
#     }
# }
# if (any(delta2_list <= 0 | !is.finite(delta2_list))) {
#     stop("delta2 contains nonpositive or nonfinite entries!")
# }
priorvar_beta <- as.matrix(Matrix::bdiag(lapply(1:K, function(g) {diag(1 / (delta2_list[g] * lambda2_list[[d]][, g]))} )))
# cat("Checking xmat for NaN/Inf...\n")
# print(any(!is.finite(xmat)))
# cat("Any rows of xmat with all zeros?\n")
# print(any(rowSums(abs(xmat))==0))
# cat("Range of xmat entries:\n")
# print(range(xmat))
#
# cat("Checking crossprod(xmat)...\n")
# cp_xmat <- crossprod(xmat)
# print(any(!is.finite(cp_xmat)))
# print(range(cp_xmat))
#
# cat("Checking priorvar_beta...\n")
# print(any(!is.finite(priorvar_beta)))
# print(range(priorvar_beta))
#
# cat("Checking vinv_beta_post before jitter...\n")
# vinv_beta_post <- cp_xmat + priorvar_beta
# print(any(!is.finite(vinv_beta_post)))
# print(range(vinv_beta_post))
vinv_beta_post <- crossprod(xmat) + priorvar_beta + diag(1e-6, nrow(priorvar_beta))
# if (any(!is.finite(vinv_beta_post))) stop("vinv_beta_post contains NA/Inf!")
# eig_vals <- eigen(vinv_beta_post, symmetric=TRUE, only.values=TRUE)$values
# print(range(eig_vals))
covBeta <- errVar * chol2inv(chol(vinv_beta_post))
xty <- crossprod(xmat, yvec)
muBeta <- drop(covBeta %*% xty) / errVar
betatilde <- muBeta + drop(crossprod(chol(covBeta), rnorm(pdims[d] * K)))
B_list[[d]] <- matrix(betatilde, pdims[d], K)
# message("Done B", d)
for(g in 1:K) {
lambda2_list[[d]][, g] <- 1 / rgamma(pdims[d], shape = 1,
rate = 1 / nu_list[[d]][, g] + (betatilde[((g-1)*pdims[d] + 1):(g*pdims[d])] ^ 2) / (2 * delta2_list[g] * errVar))
nu_list[[d]][, g] <- 1 / rgamma(pdims[d], shape = 1, rate = 1 + 1 / (lambda2_list[[d]][, g]))
# delta2_list[g] <- 1 / rgamma(1, shape = 0.5 * (pdims[d] + 1),
#                                   rate = 1 / xi_list[[d]][g] + sum((betatilde[((g-1)*pdims[d] + 1):(g*pdims[d])] * betatilde[((g-1)*pdims[d] + 1):(g*pdims[d])]) / (lambda2_list[[d]][, g])) / (2 * errVar))
# xi_list[g] <- 1 / rgamma(1, shape = 1, rate = 1 + 1 / delta2_list[g])
}
}
B <- B_cp(B_list)
### Given updated B, \lambda's, sample \delta^2_g and \xi_g ###
g_sums <- sapply(1:K, function(g) {
sum(sapply(1:nmodes, function(d) {
sum(B_list[[d]][, g]^2 / lambda2_list[[d]][, g])
}))
})
delta2_list <- 1 / rgamma(K, shape = 0.5 * (1 + sum(pdims)),
rate = 1 / xi_list + g_sums / (2 * errVar))
xi_list <- 1 / rgamma(K, shape = 1, rate = 1 + 1 / delta2_list)
################# Given updated B, sample \tau^2 #################
XijB_list <- lapply(Xijlist,
function(foo) {sum(as.vector(foo) * as.vector(B))})
mu_list <- lapply(1:n,
function(i) {
rows_i <- mis_starts[i]:mis_cumsum[i]
temp2 <- do.call("rbind", XijB_list[rows_i])
margVari_inv_half[[i]] %*% temp2
})
# mu_list <- vector("list", n)
# for(i in 1:n) {
#     temp2 <- do.call("rbind", XijB_list[((i-1)*m+1):(i*m)])
#     mu_list[[i]] <- margVari_inv_half[[i]] %*% temp2
# }
resids <- yvec - drop(do.call(rbind, mu_list))
shp_err <- a0 + 0.5 * (N + K * sum(pdims)) ## a0 = prior shape of errVar
scl_err <- b0 + 0.5 * (sum(resids^2)) ## b0 = prior scale of errVar
errVar <- 1 / rgamma(1, shape = shp_err, rate = scl_err)
#print("errVar Done")
####################################################################
##################### return samples #####################
list(BfactorsSamp = B_list,
BSamp = B, errVarSamp = errVar,
delta2Samplist = delta2_list, lambda2Samplist = lambda2_list,
nuSamplist = nu_list, xiSamplist = xi_list)
}
a0 <- 0.01; b0 <- 0.01
nmodes <- length(pdims)
#kdims <- rep(round(log(qdims[1])), nmodes)
kdims <- rep(A[id, 4], nmodes)
R_list <- vector("list", nmodes)
S_list <- vector("list", nmodes)
for(d in 1:nmodes) {
R_list[[d]] <- matrix(rnorm(kdims[d] * qdims[d], 0, sd = sqrt(1/kdims[d])), kdims[d], qdims[d])
S_list[[d]] <- matrix(rnorm(kdims[d] * qdims[d], 0, sd = sqrt(1/kdims[d])), kdims[d], qdims[d])
}
mis = rep(A[id, 2], n_train); K = A[id, 3]
gammaVar0 = rep(1, nmodes)
niter = 1100; nburn = 100; nthin = 1
library(Matrix)
library(rTensor)
n <- length(mis); N <- sum(mis)
mis_cumsum <- cumsum(mis)
mis_starts <- c(1, mis_cumsum[-length(mis)] + 1)
Sigma_gamma_list <- lapply(1:nmodes, function(d) {gammaVar0[d] * diag(kdims[d] * kdims[d])})
################## Storing final samples #####################
gammaSamplist <- lapply(1:nmodes, function(d) {matrix(NA, (niter - nburn) / nthin, kdims[d] * kdims[d])})
# betatildeSamplist <- lapply(1:nmodes, function(d) {matrix(NA, (niter - nburn) / nthin, pdims[d] * K)})
# GkronSamp <- matrix(NA, (niter - nburn) / nthin, prod(kdims) ^ 2)
betaSamp <- matrix(NA, (niter - nburn) / nthin, prod(pdims))
errVarSamp <- rep(NA, (niter - nburn) / nthin)
lambda2Samplist <- lapply(1:nmodes, function(d) {matrix(NA, (niter - nburn) / nthin, pdims[d] * K)})
nuSamplist <- lapply(1:nmodes, function(d) {matrix(NA, (niter - nburn) / nthin, pdims[d] * K)})
delta2Samp <- matrix(NA, (niter - nburn) / nthin, K) ## global shrinkage
xiSamp <- matrix(NA, (niter - nburn) / nthin, K)
####################### Initialization ######################
Gamma_list <- lapply(1:nmodes, function(d) {matrix(rnorm(kdims[d] * kdims[d], 0, sd = sqrt(gammaVar0[d])), kdims[d], kdims[d])})
#Bfactors <- lapply(1:nmodes, function(d) {matrix(0, pdims[d], K)})
#B <- B_cp(Bfactors) + array(rep(1e-4, prod(pdims)), dim = pdims)
#Bfactors <- lapply(1:nmodes, function(d) {matrix(runif(pdims[d] * K, -5, 5), pdims[d], K)})
#B <- B_cp(Bfactors)
errVar <- 1 / rgamma(1, shape = a0, rate = b0)
nu_list <- lapply(1:nmodes, function(d) {matrix(1/rgamma(pdims[d] * K, shape = 0.5, rate = 1), pdims[d], K)})
lambda2_list <- lapply(1:nmodes, function(d) {matrix(1/rgamma(pdims[d] * K, shape = 0.5, rate = 1/as.vector(nu_list[[d]])), pdims[d], K)})
xi_list <- 1 / rgamma(K, shape = 0.5, rate = 1)
delta2_list <- 1 / rgamma(K, shape = 0.5, rate = 1/xi_list)
######### ols initialization ##########
x_rows <- lapply(Xijlist, as.vector) ## Vectorize tensors X_ij's
X_mat <- do.call(rbind, x_rows)
dim(CX_m)
dim(X_mat)
gram_mat <- crossprod(X_mat)
dim(gram_mat)
# OLS estimate
beta_ols <- chol2inv(chol(gram_mat + diag(1e-6, nrow(gram_mat)), crossprod(X_mat, yijs)))
str(yijs)
str(crossprod(X_mat, yijs))
# OLS estimate
beta_ols <- chol2inv(chol(gram_mat + diag(1e-6, nrow(gram_mat)))) %*% crossprod(X_mat, yijs)
rep1 <- readRDS("/Volumes/argon_home/ArrayCME_Expts/CME/shared_global/cme3D_FES_lowrankL_cpB_K2_11k1k_n_100_m_3_Rep_1_pdims_888_qdims_888_kdims_222.rds")
rep2 <- readRDS("/Volumes/argon_home/ArrayCME_Expts/CME/shared_global/cme3D_FES_lowrankL_cpB_K2_11k1k_n_100_m_3_Rep_2_pdims_888_qdims_888_kdims_222.rds")
rep1 <- readRDS("/Volumes/argon_home/ArrayCME_Expts/CME/shared_global/cme3D_Pred_lowrankL_cpB_K2_11k1k_nTest_50_m_3_Rep_1_pdims_888_qdims_888_kdims_222.rds")
rep2 <- readRDS("/Volumes/argon_home/ArrayCME_Expts/CME/shared_global/cme3D_Pred_lowrankL_cpB_K2_11k1k_nTest_50_m_3_Rep_2_pdims_888_qdims_888_kdims_222.rds")
all.equal(rep1$R_list[[1]], rep2$R_list[[1]])
all.equal(rep1$S_list[[1]], rep2$S_list[[3]])
all.equal(rep1$S_list[[3]], rep2$S_list[[3]])
rm(list=ls())
rep1 <- readRDS("/Volumes/argon_home/ArrayCME_Expts/CME/shared_global/cme3D_Pred_lowrankL_cpB_K2_11k1k_nTest_50_m_3_Rep_1_pdims_888_qdims_888_kdims_222.rds")
rep10 <- readRDS("/Volumes/argon_home/ArrayCME_Expts/CME/shared_global/cme3D_Pred_lowrankL_cpB_K2_11k1k_nTest_50_m_3_Rep_10_pdims_888_qdims_888_kdims_222.rds")
all.equal(rep1$S_list[[3]], rep10$S_list[[3]])
all.equal(rep1$R_list[[2]], rep10$R_list[[2]])
rm(list=ls())
A <- as.matrix(expand.grid(Rep = c(1:9), m = c(3, 6, 9, 12), Kval = c(2, 5, 10), k = c(2, 4, 6)))
cme_FES_kdims_222 <- readRDS("/Volumes/argon_home/ArrayCME_Expts/CME/shared_global/cme3D_FES_lowrankL_cpB_K2_11k1k_n_100_m_3_Rep_10_pdims_888_qdims_888_kdims_222.rds")
mcmcse::mcse.mat(cme_FES_kdims_222$betaSamp)
plot(ts(cme_FES_kdims_222$betaSamp[,1]))
plot(ts(cme_FES_kdims_222$betaSamp[,18]))
plot(ts(cme_FES_kdims_222$betaSamp[seq(1,10000,by=5),18]))
plot(ts(cme_FES_kdims_222$betaSamp[seq(2001,10000,by=4),18]))
A
cme <- readRDS("/Volumes/argon_home/ArrayCME_Expts/CME/shared_global/cme3D_Pred_lowrankL_cpB_K10_11k1k_nTest_50_m_12_Rep_3_pdims_888_qdims_888_kdims_222.rds")
View(cme_FES_kdims_222)
rm(cme)
rm(cme_FES_kdims_222)
cme3D_FES_lowrankL_cpB_K10_11k1k_n_100_m_12_Rep_3_pdims_888_qdims_888_kdims_222 <- readRDS("/Volumes/argon_home/ArrayCME_Expts/CME/shared_global/cme3D_FES_lowrankL_cpB_K10_11k1k_n_100_m_12_Rep_3_pdims_888_qdims_888_kdims_222.rds")
cme3D_FES_lowrankL_cpB_K10_11k1k_n_100_m_12_Rep_3_pdims_888_qdims_888_kdims_222$sampler_time
cme3D_FES_lowrankL_cpB_K10_11k1k_n_100_m_12_Rep_10_pdims_888_qdims_888_kdims_222 <- readRDS("/Volumes/argon_home/ArrayCME_Expts/CME/shared_global/cme3D_FES_lowrankL_cpB_K10_11k1k_n_100_m_12_Rep_10_pdims_888_qdims_888_kdims_222.rds")
cme3D_FES_lowrankL_cpB_K10_11k1k_n_100_m_12_Rep_10_pdims_888_qdims_888_kdims_222$sampler_time
A
rm(list=ls())
